//资源名称1.起始不能使用特殊符号，2.图像图层名称中不能包含中文字符
const FIRST_TOKEN_REGEXP = /^([0-9]|\~|\!|\@|\#|\^|\*)/;
const CHINESE_CHAR_REGEXP = /[\u4e00-\u9fa5]/;
const DUMMY_TOKEN_LIST = [/\#/g, /\./g, / /g, /副本\d*/g, /拷贝\d*/g, /copy\d*/g];

const SHARED = "Shared";
const SHARED1 = "Shared1";

const LABEL_DEFAULT_ALIGNMENT = "UpperLeft";
const LABEL_DEFAULT_SPACEING = "1.0";
const PLACEHOLDER = "placeholder";
const NOT_EXPORT = "notexport";

const SCALE_9_GRID_REGEXP = /(_|\|)\d+,\d+,\d+,\d+/g;
const ROTATION_REGEXP = /(_|\|)(((rotation)((90)|(180)|(270)))|(right)|(down))/ig;
const BRACE_REGEXP = /\{[\s\S]*?\}/gm;
const LABEL_REGEXP = /(_|\|)(Upper|Middle|Lower)(Left|Center|Right)(,\d{1,2}(\.\d{1,3}))?/ig;
const LANG_ID_REGEXP = /(_|\|)(lang)\d+/ig;
const ALLOWED_FONT = [/.*/];//[/(MicrosoftYaHei)/, /(DroidSansFallback)/, /(FZY3K)/];//允许使用的字体名称列表根据游戏具体需求添加，通常一个游戏中只有一个字体
const IGN_SIZE_REGEXP = /(_|\|)(ignsz)/ig;  //忽略此对象的大小

//组件必须子元素校验
const TOGGLE_REGEXP = 		{required:[".*_checkmark"]};
const TOGGLE_GROUP_REGEXP = {required:["Toggle_.*"]};
const LIST_REGEXP = 		{required:[".*_item"]};
const TREE_REGEXP = 		{required:[".*_menu", ".*_detail"]};
const SLIDER_REGEXP = 		{required:[".*_fill"]};
const PROGRESS_BAR_REGEXP = {required:["Image_bar"]};
const INPUT_REGEXP = 		{required:["Label_.*"]};
const SCROLL_VIEW_REGEXP = 	{required:[".*_mask$"]};
const SCROLL_PAGE_REGEXP = 	{required:[".*_mask$"]};

//fontsize对应文本的height
const FONT_MAPPING = {
	12:12.45,
	16:17.78,
	18:19.56,
	20:21.34,
	22:24.89,
	24:26.67,
	26:28.45,
	28:30.23,
	29:32,
	30:32,
	32:35.56,
	33:35.56,
	35:37.34,
	36:40.89,
}

function Parser(environment)
{
	this.environment = environment;
	this.sharedAssetMap = {};
	this.assetMap = {};
	this.langCount = 0; //配置langId的文本框数量
	this.typeSet =
	{
		"Image":
		{
			"parser" : "parseImage",
			"validator" : "validateImage",
			"childrenRegExp" : null
		},
		"ScaleImage"://该类型不再推荐使用，只为兼容旧文件
		{
			"parser" : "parseImage",
			"validator" : "validateImage",
			"childrenRegExp" : null
		},
		"Label":
		{
			"parser" : "parseLabel",
			"validator" : "validateLabel",
			"childrenRegExp" : null 
		},
		"Input":
		{
			"parser" : "parseContainer",
			"validator" : "validateContainer",
			"childrenRegExp" : INPUT_REGEXP
		},
		"ProgressBar":
		{
			"parser" : "parseContainer",
			"validator" : "validateContainer",
			"childrenRegExp" : PROGRESS_BAR_REGEXP
		},
		"Button":
		{
			"parser" : "parseContainer",
			"validator" : "validateContainer",
			"childrenRegExp" : null
		},
		"Container":
		{
			"parser" : "parseContainer",
			"validator" : "validateContainer",
			"childrenRegExp" : null
		},
		"MaskContainer":
		{
			"parser" : "parseContainer",
			"validator" : "validateContainer",
			"childrenRegExp" : null
		},
		"List":
		{
			"parser" : "parseContainer",
			"validator" : "validateContainer",
			"childrenRegExp" : LIST_REGEXP
		},
		"Tree":
		{
			"parser" : "parseContainer",
			"validator" : "validateContainer",
			"childrenRegExp" : TREE_REGEXP
		},
		"Toggle":
		{
			"parser" : "parseContainer",
			"validator" : "validateContainer",
			"childrenRegExp" : TOGGLE_REGEXP
		},
		"ToggleGroup":
		{
			"parser" : "parseContainer",
			"validator" : "validateContainer",
			"childrenRegExp" : TOGGLE_GROUP_REGEXP
		},
		"Slider":
		{
			"parser" : "parseContainer",
			"validator" : "validateContainer",
			"childrenRegExp" : SLIDER_REGEXP
		},
		"ScrollView":
		{
			"parser" : "parseContainer",
			"validator" : "validateContainer",
			"childrenRegExp" : SCROLL_VIEW_REGEXP
		},
		"ScrollPage":
		{
			"parser" : "parseContainer",
			"validator" : "validateContainer",
			"childrenRegExp" : SCROLL_PAGE_REGEXP
		},
		"Language":
		{
			"parser" : "parseLanguage",
			"validator" : "validateContainer",
			"childrenRegExp" : null
		}
	}

	//可交互组件集合，这类组件任意深度不能相互包含，比如Button组件子元素中含有另外一个Button组件
	this.selectableSet = {"Button":1, "Toggle":1, "Slider":1};
}

Parser.prototype.loadSharedAssetXml = function()
{
	this.loadOneShared(SHARED);
	this.loadOneShared(SHARED1);
}

Parser.prototype.loadOneShared = function(sharedName)
{
	var xmlPath = this.environment.xmlFolderPath + "/" + sharedName + ".xml";
	var file = new File(xmlPath);
	if(file.exists == true)
	{
		var assetNameRegExp = /[^\\]+?(?=\.png)/gm;
		if(file.open("r") == true)
		{
			var content = file.read();
			file.close();
			var matchList = content.match(assetNameRegExp);
			for(var i = 0; i < matchList.length; i++)
			{
				this.sharedAssetMap[matchList[i]] = sharedName;
			}
		}
	}
}

Parser.prototype.parse = function(extractData)
{
	var result = this.parseTopContainer(extractData);
	result.langCount = this.langCount;
	this.validateContainer(result, "");
	return result;
}

Parser.prototype.parseTopContainer = function(extractData)
{
	var result = {};
	result.name = this.environment.psdName;
	result.type = "Container";
	result.x = 0;
	result.y = 0;
	result.param = "stretch"
	result.width = this.environment.doc.width.value;
	result.height = this.environment.doc.height.value;
	result.children = this.parseNodeList(extractData.children, "", "");
	this.removePlaceholder(result.children);
	return result;
}

Parser.prototype.parseContainer = function(node, parentPath, language)
{
	var result = this.parseFolderNodeName(node);	
	var currentPath = parentPath + "/" + node.name;
	var children = this.parseNodeList(node.children, currentPath, language);
	var bounds = this.calculateContainerBounds(children);
	this.adjustContainerBounds(result, bounds);
	this.adjustChildrenBounds(children, result);
	this.calculateContainerSelectableValue(children, result);
	this.removePlaceholder(children);
	result.children = children;
	return result;
}

Parser.prototype.parseLanguage = function(node, parentPath, language)
{
	var result = this.parseFolderNodeName(node);
	var currentPath = parentPath + "/" + node.name;
	var children = this.parseNodeList(node.children, currentPath, result.name);
	var bounds = this.calculateContainerBounds(children);
	this.adjustContainerBounds(result, bounds);
	this.adjustChildrenBounds(children, result);
	this.calculateContainerSelectableValue(children, result);
	this.removePlaceholder(children);
	result.children = children;
	return result;
}

Parser.prototype.removePlaceholder = function(children)
{
	for(var i = children.length - 1; i >= 0; i--)
	{
		if(children[i].name.toLowerCase() == PLACEHOLDER)
		{
			children.splice(i, 1);
		}
	}
}

Parser.prototype.parseLabel = function(node, parentPath, language)
{
	var result = this.parseFolderNodeName(node);
	var currentPath = parentPath + "/" + node.name;
	return this.parseStateFolderNode(node, result, "Label", "atomParseTextNode", currentPath, language);
}

Parser.prototype.parseImage = function(node, parentPath, language)
{
	var result = this.parseFolderNodeName(node);
	var currentPath = parentPath + "/" + node.name;
	return this.parseStateFolderNode(node, result, "Image", "atomParseImageNode", currentPath, language);
}

Parser.prototype.parseStateFolderNode = function(node, preprocessResult, typeName, atomParser, path, language)
{
	var result = preprocessResult;
	if(node.children.length == 0)
	{
		this.logError(path + "\n格式错误！文件夹内容为空！", node.layerIndex);
	}
	var children = [];
	for(var i = 0; i < node.children.length; i++)
	{
		var state = node.children[i];
		var stateName = this.eliminateDummyToken(state.name);
		var currentPath = path + "/" + state.name;
		if(state.type != "folder")
		{
			this.logError(currentPath + "\n格式错误！文件夹内容包含非状态文件夹内容！", state.layerIndex);
		}
		if(state.children.length == 0)
		{
			this.logError(currentPath + "\n格式错误！状态文件夹内容为空！", state.layerIndex);
		}
		if(state.children.length >1)
		{
			this.logError(currentPath + "\n格式错误！状态文件夹内容长度大于1！", state.layerIndex);
		}
		var childType = state.children[0].type;
		if(childType == "folder")
		{
			this.logError(currentPath + "\n格式错误！状态文件夹子元素是文件夹！", state.layerIndex);	
		}
		if(typeName == "Image" && childType == "text")
		{
			this.logError(currentPath + "\n格式错误！Image组件状态文件夹子元素是文本！", state.layerIndex);
		}
		if(typeName == "Label" && childType == "image")
		{
			this.logError(currentPath + "\n格式错误！Label组件状态文件夹子元素是图片！", state.layerIndex);	
		}
		result[stateName] = this[atomParser](state.children[0], currentPath, language);
		children.push(result[stateName]);
	}
	var bounds = this.calculateContainerBounds(children);
	this.adjustContainerBounds(result, bounds);
	this.adjustChildrenBounds(children, result);
	return result;
}

Parser.prototype.parseNodeList = function(nodeList, parentPath, language)
{
	var result = [];	
	for(var i = nodeList.length - 1; i >= 0; i--)
	{
		var node = nodeList[i];
		if(node.name.toLowerCase() == NOT_EXPORT)
		{
			continue;
		}
		var obj;
		if(node.type == "folder")
		{
			obj = this.parseFolderNode(node, parentPath, language);
		}
		else if(node.type == "text")
		{
			obj = this.parseTextNode(node, parentPath, language);
		}
		else if(node.type == "image")
		{
			obj = this.parseImageNode(node, parentPath, language);
		}		
		if(obj != null)
		{
			result.push(obj);
		}
	}
	return result;
}

Parser.prototype.parseFolderNode = function(node, parentPath, language)
{
	var parser = this.getFolderNodeParser(node);
	if(parser == null)
	{
		this.logError(parentPath + "/" + node.name + " \n未找到对应解析函数！", node.layerIndex) ;
	}
	return this[parser](node, parentPath, language);
}

Parser.prototype.getFolderNodeParser = function(node)
{
	var obj = this.parseFolderNodeName(node);
	var typeObj = this.typeSet[obj.type];
	return typeObj != null ? typeObj.parser : null;
}

//图层名称使用"_"分割，第一个字段为类型名，第二个为实例名，第三个为参数列表（可选）
Parser.prototype.parseFolderNodeName = function(node)
{
	var raw = this.eliminateDummyToken(node.name);
	var result = {};
	var tokenList = raw.split("_");
	result.name = this.extractNodeName(tokenList);
	result.type = this.extractNodeType(tokenList);
	result.type = (result.type == "ScaleImage") ? "Image" : result.type;
	result.param = this.extractNodeParam(tokenList);
	result.selectableValue = (this.selectableSet[result.type] != null) ? 1 : 0;
	result.layerIndex = node.layerIndex;
    
     result.ignSize = false;
     if(raw.match(IGN_SIZE_REGEXP) != null)
	{
		result.ignSize = true;
	}

	return result;
}

Parser.prototype.eliminateDummyToken = function(name)
{
	for(var i = 0; i < DUMMY_TOKEN_LIST.length; i++)
	{
		name = name.replace(DUMMY_TOKEN_LIST[i], "");
	}
	return name;
}

Parser.prototype.extractNodeName = function(tokenList)
{
	if(tokenList.length == 1)
	{
		return tokenList[0];
	}
	return tokenList[1];
}

Parser.prototype.extractNodeType = function(tokenList)
{
	var type = tokenList[0];
	if(this.typeSet[type] != null)
	{
		return type;
	}
	return "Container";
}

Parser.prototype.extractNodeParam = function(tokenList)
{
	if(tokenList.length >= 3)
	{
		return tokenList[2];
	}
	return null;
}

//提取某种参数的具体值
Parser.prototype.extractNodeParamToken = function(name, regExp)
{
	var result = name.match(regExp)[0];
	result = result.substring(1);
	return result;
}

Parser.prototype.parseImageNode = function(node, parentPath, language)
{
	var result = this.parseImageNodeName(node, language);
	result.selectableValue = 0;
	result.normal = this.atomParseImageNode(node, parentPath, language);
	var bounds = this.unionRectangle([result.normal]);
	this.adjustContainerBounds(result, bounds);
	result.normal.x = result.normal.x - result.x;
	result.normal.y = result.normal.y - result.y;
	return result;
}

Parser.prototype.parseImageNodeName = function(node, language)
{
	var raw = this.eliminateDummyToken(node.name);
	var tokenList = raw.split("_");
	var name = tokenList[0];
	var param = tokenList[1];
	var assetName = name;	
	var top = null;
	var right = null;
	var bottom = null;
	var left = null;
	var type = "Image";
	var rotation = null;
    var ignSize = false;
	if(raw.match(SCALE_9_GRID_REGEXP) != null)
	{
		var paramToken = this.extractNodeParamToken(raw, SCALE_9_GRID_REGEXP);
		var paramList = paramToken.split(",");
		top = paramList[0];
		right = paramList[1];
		bottom = paramList[2];
		left = paramList[3];
		if(top == 0 || bottom == 0)
		{
			top = Math.floor(node.height / 2);
			bottom = node.height - 1 - top;
		}
		if(right == 0 || left == 0)
		{
			right = Math.floor(node.width / 2);
			left = node.width - 1 - right;
		}
	}
	if(raw.match(ROTATION_REGEXP) != null)
	{
		rotation = this.extractNodeParamToken(raw, ROTATION_REGEXP);
		assetName = name;
		name = name + "_" + rotation;
	}
    if(raw.match(IGN_SIZE_REGEXP) != null)
	{
		ignSize = true;
	}
	if(language != "")
	{
		assetName = language + "#" + assetName;
	}
	return {name:name, type:type, param:param, assetName:assetName, rotation:rotation, top:top, right:right, bottom:bottom, left:left, ignSize:ignSize};
}

Parser.prototype.atomParseImageNode = function(node, parentPath, language)
{
	var result = this.parseImageNodeName(node, language);
	var assetName = result.assetName;
	var prefix = this.environment.psdName;
	if(this.sharedAssetMap[assetName] != null)
	{
		prefix = this.sharedAssetMap[assetName];
	}
	if(assetName != PLACEHOLDER)
	{
		this.assetMap[assetName] = prefix + "\\" + assetName;
	}
	result.link = prefix + "." + assetName;
	result.width = node.width;
	result.height = node.height;
	result.x = node.centerX - result.width * 0.5;
	result.y = node.centerY - result.height * 0.5;
	result.alpha = Math.floor(node.alpha * 100);
	result.solidFill = this.getImageSolidFillEffect(node);
	node.assetName = result.link;
	node.exportParam = result.param;
	return result;
}


Parser.prototype.getImageSolidFillEffect = function(node)
{
	if(node.effects != null && node.effects.length > 0)
	{
		var effect = node.effects[0];
		var result = {};
		result.mode = effect.mode;
		result.color = effect.color;
		result.alpha = effect.alpha;
		return result;
	}
	return null;
}

Parser.prototype.parseTextNode = function(node, parentPath, language)
{
	var result = this.parseTextNodeName(node, language);
	result.selectableValue = 0;
	result.normal = this.atomParseTextNode(node, parentPath, language);
	var bounds = this.unionRectangle([result.normal]);
	this.adjustContainerBounds(result, bounds);
	result.normal.x = result.normal.x - result.x;
	result.normal.y = result.normal.y - result.y;
	return result;
}

Parser.prototype.parseTextNodeName = function(node, language)
{
	var raw = this.eliminateDummyToken(node.name);
	var tokenList = raw.split("_");
	var name = tokenList[0];
	var param = tokenList[1];
	var alignment = null;
	var lineSpacing = null;
	var langId = null;
    var ignSize = false;
	if(raw.match(LANG_ID_REGEXP) != null)
	{
		langId = this.extractNodeParamToken(raw, LANG_ID_REGEXP);
		langId = langId.substring(4);
		this.langCount += 1;
	}
	if(raw.match(LABEL_REGEXP) != null)
	{
		var paramToken = this.extractNodeParamToken(raw, LABEL_REGEXP);
		var paramList = paramToken.split(",");
		alignment = paramList[0];
		if(paramList.length == 2)lineSpacing = paramList[1];
	}
    if(raw.match(IGN_SIZE_REGEXP) != null)
	{
		ignSize = true;
	}
	return {name:name, type:"Label", param:param, langId:langId, alignment:alignment, lineSpacing:lineSpacing, ignSize:ignSize};
}

Parser.prototype.atomParseTextNode = function(node, parentPath, language)
{
	if(node.fragments.length == 0)
	{
		this.logError(parentPath + "/" + node.name + "\n文本内容为空!", node.layerIndex);
	}
	var result = this.parseTextNodeName(node, language);
	result.content = "";
	result.format = this.parseTextDefaultFormat(node.fragments[0]);
	if(this.isFontAllowed(result.format.font) == false)
	{
		this.logError(parentPath + "/" + node.name + "\n" + result.format.font + " 字体不允许使用！", node.layerIndex);
	}
	if(node.fragments.length == 1)
	{
		result.content = node.fragments[0].text;
	}
	else
	{
		for(var i = 0; i < node.fragments.length; i++)
		{
			var fragment = node.fragments[i];
			result.content += "<color=#" + fragment.color + ">" + this.getBoldStartTag(fragment) + fragment.text + this.getBoldEndTag(fragment) + "</color>";
		}	
	}
	result.content = this.replaceBrace(result.content);
	result.content = result.content.replace(/\r/g, "\\n");
	result.width = this.getTextWidth(node.width);
	result.height = this.getTextHeight(node.height, result.format.size);
	result.x = this.getTextX(node.centerX, result.width);
	result.y = this.getTextY(node.centerY, result.height);
	result.stroke = this.getTextStokeEffect(node);
	result.shadow = this.getTextShadowEffect(node);
	result.gradient = this.getTextGradientEffect(node);
	return result;
}

Parser.prototype.getBoldStartTag = function(fragment)
{
	if(fragment.fontStyle == "Bold")
	{
		return "<b>";
	}
	return "";
}

Parser.prototype.getBoldEndTag = function(fragment)
{
	if(fragment.fontStyle == "Bold")
	{
		return "</b>";
	}
	return "";
}

Parser.prototype.getTextX = function(centerX, width)
{
	return Math.floor(centerX - width * 0.5) + 1;
}

//文本高度在preferHeight基础上加4个像素，然后y坐标移动2个像素，使上下居中
Parser.prototype.getTextY = function(centerY, height)
{
	return centerY - height * 0.5 + 2;
	// return Math.floor(centerY - height * 0.5) - 1;
}

//根据特定字体调节获取文本框宽高的计算公式
//微软雅黑
Parser.prototype.getTextHeight = function(height, fontSize)
{
	//多行文本直接返回Ps中解析的文本高度，具体使用中可能需要根据LineSpace参数，动态调整文本框高度
	if(height > fontSize * 2)
	{
		return height;
	}
	//单行文本高度计算公式
	//return fontSize + Math.floor((fontSize - 1) / 3) + 1;

	//文本高度在preferHeight基础上加4个像素，然后y坐标移动2个像素，使上下居中
	var prefer_height = FONT_MAPPING[fontSize];
	if (prefer_height == null)
	{
		return 1.1139 * fontSize - 0.4911 + 4;//采点计算线性方程
	}
	else
	{
		return prefer_height + 4;
	}
}

Parser.prototype.getTextWidth = function(width)
{
	return width + 5;
}

Parser.prototype.isFontAllowed = function(font)
{	
	for(var i = 0; i < ALLOWED_FONT.length; i++)
	{
		if(font.match(ALLOWED_FONT[i]) != null)
		{
			return true;
		}
	}
	return false;
}

Parser.prototype.replaceBrace = function(content)
{
	var result = content.match(BRACE_REGEXP);
	if(result != null)
	{
		for(var i = 0; i <result.length; i++)
		{
			content = content.replace(result[i], "{" + i + "}");
		}
	}
	return content;
}

Parser.prototype.parseTextDefaultFormat = function(fragment)
{
	var result = {};
	result.font = fragment.font;
	result.size = fragment.size;
	result.color = fragment.color;
	result.bold = (fragment.fontStyle == "Bold") ? 1 : 0;
	return result;
}

Parser.prototype.getTextStokeEffect = function(node)
{
	if(node.effects.length == 0)
	{
		return null;
	}
	for(var i = 0; i < node.effects.length; i++)
	{
		var effect = node.effects[i];
		if(effect.type == "stroke")
		{
			var result = {name:"stroke"};
			result.distance = effect.size;
			result.color = effect.color;
			result.alpha = effect.alpha;
			return result;
		}
	}
	return null;
}

Parser.prototype.getTextShadowEffect = function(node)
{
	if(node.effects.length == 0)
	{
		return null;
	}
	for(var i = 0; i < node.effects.length; i++)
	{
		var effect = node.effects[i];
		if(effect.type == "dropShadow")
		{
			var result = {name:"shadow"};
			result.angle = effect.angle;
			result.distance = effect.distance;
			result.color = effect.color;
			result.alpha = effect.alpha;
			return result;
		}
	}
	return null;
}

Parser.prototype.getTextGradientEffect = function(node)
{
	if(node.effects.length == 0)
	{
		return null;
	}
	for(var i = 0; i < node.effects.length; i++)
	{
		var effect = node.effects[i];
		if(effect.type == "gradient")
		{
			var result = {name:"gradient"};
			result.colors = effect.colors;
			result.precents = effect.precents;
			return result;
		}
	}
	return null;
}

//重新计算组件相对坐标和尺寸
Parser.prototype.calculateContainerBounds = function(children)
{
	var rectList = [];
	for(var i = 0; i < children.length; i++)
	{
		if(this.isEmptyChild(children[i]) == false)
		{
			rectList.push(children[i]);
		}
	}
	return this.unionRectangle(rectList);
}

Parser.prototype.unionRectangle = function(rectList)
{
	if(rectList.length == 0)
	{
		return {x:0, y:0, width:0, height:0};
	}
	var left = Number.MAX_VALUE;
	var top = Number.MAX_VALUE;
	var right = Number.MIN_VALUE;
	var bottom = Number.MIN_VALUE;
	for(var i = 0; i < rectList.length; i++)
	{
		var rect = rectList[i];
         if (rect.ignSize)
         {   
              continue;
         }
        
		left = (left > rect.x) ? rect.x : left;
		top = (top > rect.y) ? rect.y : top;
		right = (right < (rect.width + rect.x)) ? (rect.width + rect.x) : right;
		bottom = (bottom < (rect.height + rect.y)) ? (rect.height + rect.y) : bottom;
	}
	return {x:left, y:top, width:right - left, height:bottom - top};
}

Parser.prototype.adjustContainerBounds = function(obj, bounds)
{
	obj.x = bounds.x;
	obj.y = bounds.y;
	obj.width = bounds.width;
	obj.height = bounds.height;
}

Parser.prototype.adjustChildrenBounds = function(children, parent)
{
	for(var i = 0; i < children.length; i++)
	{
		var child = children[i];
		if(this.isEmptyChild(child) == true)
		{
			child.x = 0;
			child.y = 0;
		}
		else
		{
			child.x = child.x - parent.x;
			child.y = child.y - parent.y;
			if(child.type == "Language")
			{
				this.adjsutLanguageChildrenBounds(child);
			}
		}
	}
}

//Selectable不能相互嵌套：Selectable组件的任何次级子元素不能为Selectable组件
//该算法计算每个组件节点的SelectableValue，当节点自身为Selectable且selectableValue大于1时,
//该组件的结构非法
Parser.prototype.calculateContainerSelectableValue = function(children, parent)
{
	for(var i = 0; i < children.length; i++)
	{
		parent.selectableValue += children[i].selectableValue;
	}
}

//语言设置容器，在结构中是不占位置的，所以其子元素的位置需要重新计算
Parser.prototype.adjsutLanguageChildrenBounds = function(languageObj)
{
	for(var i = 0; i < languageObj.children.length; i++)
	{
		var child = languageObj.children[i];
		child.x = child.x + languageObj.x;
		child.y = child.y + languageObj.y;
	}
}

Parser.prototype.isEmptyChild = function(child)
{
	if(child.x == 0 && child.y == 0
		&& child.width == 0 && child.height == 0)
	{
		return true;
	}
	return false;
}

//==============================检验解析结果================================
Parser.prototype.validateContainer = function(result, parentPath)
{
	this.validateName(result, parentPath);
	parentPath = parentPath + "/" + result.type + "_" + result.name;
	this.validateChildren(result, parentPath);
	var len = (result.children != null) ? result.children.length : 0;
	for(var i = 0; i < len; i++)
	{
		var child = result.children[i];
		var validator = this.getTypeValidator(child.type);
		if(validator != null)
		{
			this[validator](child, parentPath);
		}
	}
	//可扩展，增加重名元素检查
}

Parser.prototype.validateImage = function(result, parentPath)
{
	this.validateName(result, parentPath);
	for(var state in result)
	{
		var stateObj = result[state];
		if(stateObj instanceof Object)
		{
			if(stateObj.link != null)
			{
				var link = stateObj.link;
				var imageName = link.substring(link.indexOf(".") + 1);
				this.validateName({type:result.type, name:imageName}, parentPath + "/" + state);
				var statePath = parentPath + "/" + result.name + "/" + state + "/" + imageName;
				if(stateObj.top == undefined || stateObj.right == undefined || stateObj.bottom == undefined || stateObj.left == undefined)
				{
					continue;
				}
				if((parseInt(stateObj.top) + parseInt(stateObj.bottom)) >= stateObj.height)
				{
					this.logError("九宫图像图层【" + statePath + "】top和bottom参数之和必须小于图片height(高度)值！");
				}
				if((parseInt(stateObj.right) + parseInt(stateObj.left)) >= stateObj.width)
				{
					this.logError("九宫图像图层【" + statePath + "】right和left参数之和必须小于图片width(宽度)值！");
				}
			}
		}
	}
}

Parser.prototype.validateLabel = function(result, parentPath)
{
	this.validateName(result, parentPath);
}

Parser.prototype.validateChildren = function(result, parentPath)
{
	var regExp = this.getTypeRegExp(result.type);
	if(regExp == null)
	{
		return;
	}
	var requiredCount = regExp.required.length;
	var children = result.children;
	outer:
	for(var i = 0; i < requiredCount; i++)
	{
		var required = regExp.required[i];
		for(var j = 0; j < children.length; j++)
		{
			var child = children[j];
			var candidate = child.type + "_" + child.name;
			if(candidate.match(required) != null)
			{
				continue outer;
			}
		}
		var content = parentPath + "组件【" + result.type + "_" + result.name + "】格式错误！\n";
		content += "子元素" + required.replace("$", "") + "未找到！";
		this.logError(content, result.layerIndex);
	}
}

Parser.prototype.validateName = function(result, parentPath)
{
	if(result.name.match(FIRST_TOKEN_REGEXP) != null)
	{
		this.logError(parentPath + "/" + result.type + "_" + result.name + "\n命名格式错误！名字以数字或特殊符号开始！", result.layerIndex);
	}
	if(result.name.match(CHINESE_CHAR_REGEXP) != null)
	{
		this.logError(parentPath + "/" + result.type + "_" + result.name + "\n命名格式错误！名字中包含中文字符！", result.layerIndex);	
	}
	if(this.selectableSet[result.type] != null && result.selectableValue > 1)
	{
		this.logError(parentPath + "/" + result.type + "_" + result.name + "\n交互组件次级元素中包含其他可交互组件！", result.layerIndex);
	}
}

Parser.prototype.getTypeRegExp = function(type)
{
	return this.typeSet[type].childrenRegExp;
}

Parser.prototype.getTypeValidator = function(type)
{
	return this.typeSet[type].validator;
}

Parser.prototype.logError = function(content, layerIndex)
{
	if(layerIndex != undefined)
	{
		this.highlightLayer(layerIndex);	
	}
	throw new Error(content);
}

Parser.prototype.highlightLayer = function(layerIndex)
{
	var descriptor = new ActionDescriptor();
	var reference = new ActionReference();
	reference.putIndex(ST("layer"), layerIndex);
	descriptor.putReference(ST("null"), reference);
	executeAction(ST("select"), descriptor, DialogModes.NO);
}
